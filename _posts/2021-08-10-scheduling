---
layout: single
title:  "스케줄링 Scheduling"
categories: Os
tags: [Os, ComputerScience]
toc: true

---

<br><br>

# 스케줄링의 기본 개념 

 \- 대기열 모델 : server – requests. 리퀘가 들어오면 서버 內 큐에 넣어져 대기

 \- 비선점 & 선점 서버 : 비선점 서버는 비선점 스케줄링만 가능, 선점 서버는 다 가능

<br><br><br><br>    

​    

# CPU 스케줄링 (short-term) 

 \- ready queue의 프로세스들 中 어떤 프로세스가 이후에 (얼마나 오래) 실행될 것인가?

 \- 스케줄러(Dispatcher)

   : 인터럽트, 예외, 시스템 콜처럼 실행시킬 다른 프로세스를 선택시킬 이벤트에 의해 촉발

   : process switching을 통해 프로세스에 CPU 제어 권한을 부여함

   : 참고로 리눅스에서는 dispatcher 없다. 스케줄러가 커널 코드의 일부로써 작동하기 때문

 \- 지연 시간 : 프로세스 하나 중단시키고 다른 녀석 실행시키는 데 걸리는 시간

​               real-time OS에서 치명적이다

​    

​    

## CPU 스케줄링의 기준 

 \- CPU 지향 (시스템) : ① 활용률 - CPU를 최대한 많이 쓴다

​         ② 처리량 - 시간 당 실행을 완료하는 프로세스의 수

 \- 프로세스 지향 (사용자) : ① 처리 시간 – 특정 프로세스를 실행하는 시간

​      ② 대기 시간 – ready queue에서 프로세스가 대기하는 시간

​      ③ 응답 시간 – 리퀘 접수 시점부터 첫 응답까지 걸리는 시간

   ![img](file:///C:\Users\Shako\AppData\Local\Temp\DRW000040144703.gif)   최적화 기준 : ① CPU 활용률 & 처리량의 “극대화”

​    ② 처리시간 & 대기시간 & 응답시간의 “최소화”

​    

​    <br><br><br><br>

# 프로세스 동작 : CPU-bound & I/O-bound

 \- CPU-I/O 사이클

   : 프로세스는 CPU와 I/O를 반복적으로 사용해야 한다.

​     각 사이클은 CPU burst와 I/O burst로 구성된다. (보통 CPU burst가 더 길다)

​     CPU-bound 프로세스는 I/O-bound 프로세스보다 CPU burst의 길이가 더 길다.

​    <br><br><br><br>

​    

# 우선순위 개념 

 \- 리퀘스트는 각각의 우선순위에 근거해 처리된다. (우선순위 번호는 각 프로세스와 연결됨)

   : 스케줄러는 항상 높은 우선순위의 프로세스를 선택한다.

​     실제로 우선순위 스케줄링은 단계별 우선순위를 나타내는 여러 ready queue로 실행함.

 \- 선점 or 비선점 방식이다.

 \- starvation 이슈 : 낮은 순위 리퀘는 하염없이 기다린다...

​     시간이 지날수록 해당 프로세스의 순위를 높이는 방법(**aging**) 등이 있다.

<br><br><br><br>

# 스케줄링 정책의 특성화

 \- 선택 기능 : ready queue에서 어떤 프로세스를 다음으로 선택할 것인가?

 \- 결정 모드 : ‘선택 기능’을 어느 시간대에 활성화할 것인가?

​               ① 비선점 : 실행 중 프로세스가 종료되거나 block될 때까지 계속 실행시킴

​        ② 선점 : 실행 중 프로세스 중단(시한 만료)시키고 ready 상태 만들기 가능<br>

​    특정 프로세스의 프로세서 장기 독점 방지 → 더 나은 서비스다!

​    

​    

## 선택 기능 : 이럴 때 CPU 스케줄링 decision이 일어나요~!

 ① run에서 wait 상태로 switch할 때

 ② run에서 ready 상태로 switch할 때

 ③ wait에서 ready 상태로 switch할 때

 ④ 종료될 때<br>

 ※ ①과 ④만 ‘비선점’이고 나머지는 전부 ‘선점’ 형식이다.

​    <br><br><br><br>

​    

# FCFS 스케줄링

 \- 원리

  : ① ready queue에서 가장 오래 기다린 프로세스를 다음 실행 프로세스로 선택

​    ② 일반적으로 비선점 형식이다 (time quantum 없고, blocking 없이 중단 안 됨)

 \- 문제점

  : ① 입출력과 관련 없는 프로세스가 프로세서를 독점할 가능성 존재

​    ② CPU-bound 프로세스를 선호함, 따라서 I/O 프로세스가 무한정 기다려야 한다.

​       → 그나마 I/O-bound 프로세스에 우선순위를 줌으로써 완화 가능

​    <br><br><br><br>

​    

# Round Robin 방식

 \- 원리

  : ① 다음 실행될 프로세스 선택 방법은 FCFS와 동일

​    ② 시분할에 따른 선점 형식이다 (time quantum 동안 실행 후 인터럽트 발생)

 \- 특징

  : ① time-sharing 환경에 적합

​    ② 리퀘스트의 잦은 switching으로 인한 overhead 발생

​    ③ 따라서 퀀텀이 작을수록 성능이 떨어진다. overhead가 자주 발생하니까.

​    <br>

 ※ 퀀텀이 timer 인터럽트 & dispatching하는 데 걸리는 시간보다 커야 한다.

 ※ 여전히 CPU-bound 프로세스 선호

​    : I/O-bound의 경우 퀀텀보다 짧은 시간 내에 CPU 쓰고 I/O 인터럽트 기다린다...

​     그래서 모든 퀀텀마다 충실히 실행되는 CPU-bound가 선호되는 듯.

<br><br><br><br>

# SJF 스케줄링

 \- 원리

  : ① CPU burst 시간이 가장 짧을 것으로 예상되는 프로세스를 다음으로 선택

​    ② 선점 형식일수도, 비선점일수도 있습니다 (like 안철수) : 선점이면 SRTF 방식!

​    ③ 최적화 알고리즘 : “평균 대기시간”을 최적화하는 알고리즘

 \- 특징

  : ① I/O-bound 프로세스가 우선적으로 선택됨

​    ② CPU burst의 길이를 측정하기가 어려움

​    ③ CPU burst가 긴 리퀘는 하염없이 기다린다...

​    <br><br>

​    

## CPU burst 측정하기

 ① 단순 평균화

   \- T[i] : 이 프로세스의 i번째 CPU burst의 “실제 지속 시간”

   \- S[i] : 이 프로세스의 i번째 CPU burst에 대한 “예측값”

   \- S[n+1] = (1/n) Sum { i=1 to n } T[i] (즉 그냥 단순한 평균 구하기임)

   \- 매번 전체 합 구하기 버거우므로 S[n+1] = (1/n) T[n] + ((n-1)/n) S[n] 이렇게 써 줌

   \- 그러나 이건 각 항목마다 동일한 가중치를 부여한 경우임

 ② 지수 평균화

   \- 최근의 항목들이 미래의 행동을 반영할 가능성이 높음

   \- 그래서 지수 평균을 이용한다 : S[n+1] = a T[n] + (1-a) S[n]; 0 < a < 1

   \- a가 1/n보다 크면 최근의 항목들에 더 큰 가중치를 부여

   \- 위 식의 확장 ☞ 과거 항목의 가중치 급격히 감소

​     : S[n+1] = aT[n] + (1-a)aT[n-1] + ... (1-a)^{i}aT[n-i] + ... + (1-a)^{n}S[1]

   <br><br><br><br> 

​    

# 멀티레벨 Queue 스케줄링

 \- 원리

  : ① 서로 다른 알고리즘에 의해 여러 가지의 ready queue가 스케줄링된다

​    ② 각 queue는 고유의 스케줄링 알고리즘이 있다

​    ③ 스케줄링은 반드시 queue들 사이에서 이루어진다

​      → 고정 우선순위 스케줄링

​      → 각 queue는 프로세스를 스케줄할 특정 CPU time (time slice)을 부여받는다

​    ④ 매개변수 : 각 queue의 스케줄링 알고리즘 / queue의 수 / 다음 리퀘 선택 알고리즘

<br><br><br><br>

# 멀티레벨 피드백 Queue 스케줄링 (MLFQ)

 \- 원리

  : ① 프로세스가 queue들 사이를 이동 가능 (이 방법으로 aging 구현이 된다)

​    ② 동적 우선순위를 통한 선점 방식

​    ③ 여러 개의 ready 상태의 queue가 순위 내림차순 순서대로 있음

​    ④ I/O-bound 프로세스가 CPU-bound보다 높은 순위를 배정받음

​    ⑤ 자기보다 높은 순위의 queue가 없을 때에만 그 queue 內에서 다음으로 선택받는다

​    ⑥ 그렇기에 마지막 queue에서는 Round Robin 방식이 되므로 긴 작업은 하염없wait,,,

​    <br><br><br><br>

​    

# Fair Share 스케줄링 (FSS)

 \- 원리

  : ① 다중 사용자 system에서는 각 사용자가 여러 프로세스를 가질 수 있음

​    ② 사용자는 group에 속하며 각 group은 CPU의 공정한 share를 받아야 한다

​    ③ 각 사용자는 프로세스의 share를 할당받는다

​    ④ 가령 group별 중요도가 같고, 한 group이 다른 group보다 프로세스가 더 많으면 그 group에 대한 응답시간의 저하가 더 뚜렷해야 한다.

 <br><br><br><br>   

​    

# Multiple-Processor 스케줄링

 \- CPU 여러 개를 사용 가능한 경우에는 스케줄링이 더 복잡해진다

 \- 동종 프로세서의 개수와 load의 sharing 문제 등등으로 복잡해지는 것으로 보임

​    

​    <br><br><br><br>

# UNIX 스케줄러

 \- 핵심 원리

  : ① “CPU-bound 프로세스보다 interactive 프로세스를 보상한다”

​    ② interactive 프로세스는 보통 짧은 CPU burst를 사용해 실행됨

​    ③ 응답시간을 최소화하고자 함

​    ④ CPU-bound 작업은 실행이 지연될 수밖에 없음<br>

 \- 일반적인 구현

  : ① (많은 우선순위 level에 걸친) 3~4 classes의 MLFQ를 사용한다.

​    ② queue 內에선 round robin, queue들 사이에선 우선순위 스케줄링 방식

​    ③ 동적 우선순위 적용

<br><br><br><br>



# Real-Time 스케줄링

① Hard Real-time System

 \- 보장된 시간 내에 중요한 작업을 완료해야 함

 \- 리소스 예약 : 프로세스는 리소스의 요구사항과 함께 제출된다

 \- 최악의 타이밍 분석이 필요 : 실행 시간의 불가피한 변동 최소화, but 

​                              보조 저장매체 or 가상메모리 있는 시스템에서 매우 어렵다

 \- 보통, 기능이 제한된 전용 하드웨어에서 실행되는 특수 목적 소프트웨어로 구성됨

 \- 스케줄링 알고리즘 : EDF, RM(Rate Monotonic) etc.<br>

② Soft Real-time System

 \- 중요한 프로세스가 더 우선 : 자원의 불공정한 배분 야기 → 일부 하염없wait 초래할수도

 \- 요구사항 : 우선순위 스케줄링 필요 (가급적이면 real-time 스케줄링 class)

​              dispatch 지연 시간은 작아야 함

 \- dispatch 지연 시간 줄이기 : 커널 전체를 preemptable하게 만듦

​         ‘선점 포인트’에서 시스템 콜이 선점되도록 하면 됨<br>

③ 우선순위 반전 문제

 \- 간혹 불필요하게 높은 우선순위의 프로세스/스레드가 지연되거나 block된다

​    

​    <br><br><br><br>

# 알고리즘 평가 방법

시스템 workload / 응답 시간, 처리량 등의 상대 가중치 / 등 요소에 따라 평가 가능

① 결정론적 모델링

 : 미리 결정된 특정 workload 사용, 이 workload에 대한 각 알고리즘의 성능을 정의

   간편하고 빠르나, 구체적이고 정확한 지식이 필요하다

② Queueing 모델

③ (trace 기반) 시뮬레이션 분석

 : trace를 입력으로 사용한 시뮬레이션 (trace : real system의 이벤트에 대한 순서 레코드)

​    
