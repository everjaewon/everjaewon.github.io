---
layout: single
title:  "입출력 시스템 I/O System"
categories: Os
tags: [Os, ComputerScience]
toc: true

---

<br><br>

# “입출력 하드웨어” 세부 정보

CPU 측 : 입출력 버스 & 입출력 주소

 • 하드웨어 장치와 소통할 주소

 • 물리적 메모리 주소 공간에 mapping될 수 있음

<br>

장치 측 : 하드웨어 컨트롤러

 • CSR(컨트롤 & 제어 레지스터)

하드웨어 장치와 interact할 방법은 3가지

 ① 폴링

 ② 인터럽트 기반

 ③ 직접 메모리 접근 (DMA)

​    <br><br><br>

​    

## 입출력 구조

① 입출력 포트, ② 입출력 인터페이스, ③ 장치 컨트롤러 3개 요소로 구성된다!

<br>

① 입출력 포트

 • 입출력 버스에 연결된 각 장치는 각자 고유 입출력 주소를 갖는데, 이게 ‘입출력 포트’다.

 • 각 장치의 입출력 포트는 특수화된 레지스터 모음으로 구조화된다.

 • in, ins, out, outs 명령을 통해 CPU와 입출력 포트 간에 데이터 전송이 이루어진다.

<br>

② 입출력 인터페이스

 • 입출력 포트와 그에 상응하는 장치 컨트롤러 사이에 삽입되는 하드웨어 회로.

 • 입출력 포트의 value들을 장치의 명령과 데이터로 translate하는 interpreter 역할임.

 • 사용자 정의 입출력 인터페이스 : 키보드, 그래픽, 디스크, 네트워크 etc.

 • 범용 입출력 인터페이스 : 병렬 포트, 직렬 포트, USB/PCMCIA/SCSI 인터페이스

<br>

③ 장치 컨트롤러

 • 입출력 인터페이스한테 받은 고급 명령을 해석하고, 장치에 적절한 일련의 전기신호를 보내서 그걸 수행하도록 강요함.

 • 장치한테 받은 전기신호를 적절히 해석하고 변환함. 그리고 상태 레지스터의 값을 수정함.

<br><br><br>

## 폴링  VS  인터럽트

폴링 입출력

 • 필요한 경우에 CPU가 장치에 attention을 요청함.

 • 장점 : 간단하고 소프트웨어가 제어됨, CPU가 곧 준비될 장치를 찾는 경우에 효과적

 • 단점 : 중요한 시스템(높은 CPU 활용도 etc.)에서 비효율적임

<br>

인터럽트 기반 입출력

 • attention 필요할 때 입출력 장치가 인터럽트 보냄

 • 각 장치에 관련한 인터럽트 service routine이 호출됨.

 • 인터럽트는 다수의 장치들 간 공유 가능

 • 장점 : CPU가 필요할 때만 장치에 참여 가능, 보통 폴링보다 효과적임

 • 단점 : 초과 인터럽트는 프로그램 실행을 늦추거나 방해함 / 오버헤드 문제

​    <br><br><br>

​    

## 직접 메모리 접근(DMA) 

입출력 장치와 메모리 간에 직접적인 데이터 전송을 위해, CPU를 우회한다.

  대규모 데이터 이동에 대한 ‘programmed I/O’을 방지하는 데에 사용됐다.

  (programmed I/O : CPU가 state bit를 반복적으로 검사하면서 1바이트씩 옮기는 입출력 방식)

  DMA 컨트롤러가 필요하다.

<br>

DMA의 모드들

 ① 사이클 훔치기

  • DMA 컨트롤러가 잠시동안 CPU에 숨어들어서 occasional bus cycle을 훔친다. 즉 조금조금씩 가져와서 야금야금 쓴다는 이야기!

 ② 버스트 모드

  • DMA 컨트롤러가 버스를 얻고, 전송 series를 실행한 뒤, 버스를 놓아준다.

  • 사이클 훔치기보다 효과적이다 : 버스를 얻는 건 시간이 걸리고, 버스 한 번 얻는 비용만으로 다수의 word를 전송할 수 있다.

  • 한 마디로, "담비꺼야ㅏㅏㅏ" 하고 bus를 볼 일 다 볼 때까지 쥐고 안 놔준다? 라고 생각하면 단순하다.

<br>

DMA에서의 주소 지정

 • OS가 메모리 버퍼의 가상 주소를 물리적 주소로 변환하고, 이걸 DMA 컨트롤러의 주소 레지스터에 기록한다.

 • 대상 메모리 영역은 DMA동안 페이징으로 방출되는 일 없이 고정되어 있어야 한다.

​    <br><br><br>

​    

## 입출력 하드웨어 접근

장치는 주소를 갖고 있다. ① 직접 입출력 명령, ② 메모리에 매핑된 입출력에서 쓰인다.

① 장치 입출력

 • 입출력 포트의 주소에 특별한 입출력 명령어를 사용한다. (in, ins, out, outs)

② 메모리에 매핑된 입출력

 • 장치 컨트롤 레지스터들이 프로세서의 주소공간에 mapping된다.

 • CPU가 표준 데이터 전송 명령을 써서 입출력 요청을 실행한다.

 • 사용자 프로세스가 입출력 수행하는 것을 막을 특수한 보호 메커니즘이 필요없다.

 • 장치 레지스터를 읽고 그 값을 testing하는 것은 명령어 하나로 이뤄진다.

(https://ko.wikipedia.org/wiki/메모리\_맵\_입출력) ← 참조!

<br><br><br><br>

# 입출력 소프트웨어

프로그램 입출력 인터페이스

 • 장치가 엄청 다양할 때, OS가 어떻게 프로그램들에게 편안한 동일 입출력 인터페이스를 제공할 수 있을 것인가?

<br>

목표

 ① 장치 독립성 : 프로그램은 장치를 미리 지정할 일 없이 어느 입출력 장치에나 접근 가능

 ② 동일한 이름짓기 방식 : 파일/장치의 이름은 문자열이거나 정수여야 함

 ③ 효과적인 오류 처리 : 하드웨어에 가능한 한 가깝게 처리

 ④ 퍼포먼스 : 장치에서 오는 데이터는 최종 목적지에 저장될 수 없음

 <br><br><br><br>   

​    

# 장치 드라이버 

장치 드라이버

 • “‘장치 독립적 입출력 소프트웨어’ & ‘인터럽트 handler’와 interact하는 각 입출력 장치”를 제어하는 장치별 code.

 • 장치들이 OS의 나머지 부분과 어떻게 interact하는지에 대한 표준 인터페이스와 잘 설계된 model을 정의해야 함

 • 장치 드라이버 구현 : 커널과 정적으로 연결됨 / 실행 중에 system에서 동적으로 load됨

 • Non-standard/Standard 드라이버 인터페이스

​    <br><br><br>

​    

## 장치 독립적인 입출력 소프트웨어

장치 드라이버들에 대한 동일한 인터페이스

 • UNIX에서는 장치들이 특수한 ‘파일’로 모델링됨

  : open(), read(), close() 같은 시스템 콜을 사용해 접근됨

​    파일 이름은 각 장치와 관련되어 있음

 • 주요 장치 번호가 적절한 드라이버를 찾음

  : minor 장치 번호는 드라이버의 매개변수로서 통과된다. 읽고 쓸 unit 지정을 위해.

 • 파일의 일반적인 보호 규칙들은 입출력 장치에도 적용됨

<br>

오류 보고

 • 오류들은 장치마다 다르고, 적절한 드라이버에 의해 처리되어야 한다.

   하지만, 오류 처리를 위한 framework는 장치마다 다르다.

 • 오류 처리 : 오류 코드와 함께 시스템 콜 반환

​        특정 횟수동안 재시도

​               오류 무시

​               호출 프로세스 중단

​               시스템 종료

<br>

장치 독립적인 block size

 • 여러 sector를 하나의 논리적 block으로 간주

 • 상위 계층은 모두가 같은 block size를 사용하는 abstract한 장치만 처리함

<br><br><br>

## 사용자 공간 입출력 소프트웨어

라이브러리 형식으로 제공된다. (C언어의 표준 입출력 라이브러리)

 • fopen()  vs open()

 • fgetc()를 위한 buffering

<br>

스풀링

 • 멀티프로그래밍 시스템 전용 입출력 장치를 처리하는 방법

 • daemon과 스풀링 디렉토리에 의해 구현됨

 • 프린터, 네트워크 파일 전송, 메일 etc.

​    <br><br><br>

​    

## Linux 장치 드라이버

역할

 • 커널/사용자를 위한 명확한 인터페이스 제공

 • loadable한 커널 모듈로 구현됨

<br>

장치 드라이버의 작동 :

 • 장치 파일 작업을 호출

 • 장치 드라이버 등록

 • 장치 드라이버 초기화

 • 입출력 작업 모니터링

<br><br><br><br>    

​    

# 입출력 성능 향상

입출력 : 시스템 성능의 주요 병목 현상

 • CPU가 장치 드라이버 & 커널 입출력 코드 수행하도록 요구함

 • 인터럽트로 인한 모드 switching

 • 데이터 복사

 • 네트워크 트래픽

<br>

지침

 • 모드 switching의 횟수 감소

 • 데이터 복사 감소

 • large transfer와 smart controller를 사용해서 인터럽트를 줄임

 • DMA를 사용

 • 프로세싱 primitives를 하드웨어로 옮김 : CPU와 장치 컨트롤러의 동시 작동

 • 처리량 극대화를 위해 CPU, 메모리, 버스, 입출력 성능의 균형을 맞춤
