---
layout: single
title:  "교착상태 Deadlock"
categories: Os
tags: [Os, ComputerScience]
toc: true

---

<br><br>

# 교착 상태 

 \- 프로세스 set에서 각각 리소스 보유하고 있고, set 내 다른 애가 가진 리소스를 얻기 위해 대기하는 blocked 프로세스의 집합

 \- 하드웨어 전반 or 프로세스 전반에 걸쳐 발생 가능

​    <br>

 \- 다리가 리소스, 자동차가 프로세스면 외다리에서 누군간 후진해야 / starvation도 가능!

​    <br>

 \- graph에서도 cycle만 안 만들어지면 교착 상태 없음 → cycle이 교착상태의 필요조건

 \- cycle 만들어졌는데 리소스들에 타입이 각 1개씩만 있으면 교착 상태임 (충분조건이 아닌 이유)

​    <br><br><br>

​    

## 교착 상태 필수 조건

아래 4가지 조건이 “동시에” 유지되어야 발생함<br>

① 상호 배제 : 한 번에 하나의 프로세스만 리소스 사용 가능

② Hold & Wait : 리소스를 hold한 프로세스가 다른 프로세스가 hold한 리소스를 wait

③ 비선점 : 리소스 가진 프로세스가 자발적으로 release해야만 가능

④ 순환 대기 : cycle 형성

  <br><br>  <br>

​    

## 교착 상태를 다루는 방법

① 교착 상태 방지(회피) : system이 절대로 교착 상태 안 되도록 보장

② 교착 상태 탐지/복구 : system이 교착 상태 되는 것은 가능, 단 그걸 복구함

③ 암 것도 안함 : 걍 무시하고 없는 걸로 간주 (놀랍게도 대다수 OS에서 채택;;)

​    <br><br>

​    

### 1-1. 교착상태 예방

\- 필수조건 4가지 중 하나가 절!대! 안 일어나게 하자

① 상호 배제 : 공유 불가능 리소스에 대해서는 할 수 있는 게 없음.

​              뭔 소리냐? 이거 안 되게 하면 파장 개크다는 의미임. 그러므로 포기하렴!

② Hold & Wait : 리소스 요청할 거면 아무것도 hold하지 않은 상태여라.

​    아니면 애초 실행 시작하기 전에 필요한 모든 리소스를 요청해라.

③ 비선점 : hold한 상태에서 당장 할당 안 되는 리소스 요청 시, 지금 hold한 것도 싹 다 release해버린다. 요청한 리소스 말고도 release당해버린 것까지 되찾을 수 있으면 그 때 다시 시작하게 해주마.

④ 순환 대기 : 리소스마다 고유 번호 부여, 프로세스에서 번호 순서대로 요청하도록 한다.<br><br><br>

### 1-2. 교착상태 회피

리소스 할당과 런타임 체크를 통해 교착상태를 회피한다

각 프로세스가 필요할 수 있는 최대 리소스 수를 선언

자원 할당 상태를 동적으로 검사 : cycle 발생 방지 보장

자원 할당 상태 : 가능한 자원 수 & 할당된 자원 수 & 프로세스 필요 최대 리소스 수

​    

​    

#### 안전 상태

프로세스가 가능 리소스를 요청할 때, system이 해당 요청에 대한 즉시 할당이 'system을 안전 상태로 두는지'를 확인해야 한다.

모든 프로세스들에 대한 **안전 순서**가 있을 경우 system이 안전 상태에 있다고 말함.

<br><br>

​    

※ 안전 상태면 교착 상태는 없다. 비안전 상태면 가능성이 있다.

※ ‘회피’는 system이 **절!대!** 비안전 상태로 진입하지 않도록 보장하는 방법이다.

   <br><br> 

​    

#### 뱅커 알고리즘 (회피 방법)

프로세스의 자원 할당 요청을 받아들였을 때 안전 순서가 존재한다면 받아들이고, 아니라면 대기시킨다.

① Available[j] : 모든 자원 j에 관한 사용 가능 개수

  ② Max[i, j] : 프로세스 i가 제시한 자원 j에 관한 최대 요구 개수

  ③ Allocation[i, j] : 프로세스 i에 할당된 자원 j의 개수

  ④ Need[i, j] : 프로세스 i가 추가적으로 필요로 하는 j의 개수

​    <br>

※ 안전 알고리즘

① Work는 사용 가능 자원 수 배열, Finish는 false로 처리된 프로세스 개수 성분의 배열

② Finish i번째가 false고 Need가 Work보다 작거나 같으면 ③으로, 그런 i 없으면 ④로.

③ Work에 Allocation 더하고 Finish는 true로 바꾼 뒤 ②로.

④ 모든 i에 대해 Finish true면 그 system은 안전 상태다.<br><br><br>

### 2. 교착 상태 탐지 & 복구

system 교착되게 냅두고 그 후에 deal한다.

리소스 요청에 대한 선험적 정보 없음

뱅커 알고리즘의 safety 알고리즘에서 Need를 Request로 바꿨을 때 안전 순서가 없으면

  → system은 교착된다.

​    <br>

​    <br>

#### 탐지 알고리즘

① Work는 사용 가능 자원 수 배열, Finish는 allocation 0이면 true, 아니면 false로.

② Finish i번째가 false고 Request가 Work보다 작거나 같으면 ③으로, 그런 i 없으면 ④로.

③ Work에 Allocation 더하고 Finish는 true로 바꾼 뒤 ②로.

④ Finish가 false인 i가 있으면 system은 교착된다. 또한 그 프로세스 i에서 교착된다.

​    <br>

※ 탐지 알고리즘을 매 요청마다 수행하는 건 상당한 오버헤드를 발생시킬 수 있음

​    <br><br>

​    

#### 교착상태 복구

① 프로세스 종료 : 종료된 프로세스에 할당된 모든 리소스 회수

  \- 교착된 프로세스를 전부 중지시킨다.

  \- 교착 cycle이 없어질 때까지 차례로 교착 프로세스를 중지시킨다.

  \- 그렇다면 어떤 차례로?

​    \1) 프로세스의 우선순위

​    \2) 연산 시간 & 남은 수행 예상 시간

​    \3) 프로세스가 사용한 리소스

​    \4) 프로세스가 종료까지 필요로 하는 리소스

​    \5) 종료되어야 하는 프로세스의 수

​    \6) 프로세스가 interactive인지 아닌지

  → 파일, 인쇄 작업 등 system이 일관되지 않을 수 있으므로, 쉽지 않은 방법이라고 하더라

​    <br>

② 자원 선점

  \- 희생자 선택 : 어떤 리소스와 프로세스를 선점할까?

  \- 역행 : 프로세스로부터 자원을 선점하면, 그 프로세스는 어떻게 될까?

​           안전 상태로 돌아가서 프로세스를 다시 시작

  \- Starvation : 발생 안 한다고 어떻게 보장할까? 늘 동일한 프로세스가 희생자로 선택됨
  <br><br><br><br><br>
# <span style="color:yellow">핵심 질문</span>
⑴ deadlock 발생을 위한 4가지 필요조건에 대해 간단히 설명하고, 이들이 충분조건이 아닌 이유에 대해 설명하시오<br>
⑵ 은행원 알고리즘에 대한 간단한 설명
<br><br><br><br>
⑴<br>데드락이 발생하기 위해 동시에 유지되어야 할 4가지 조건은 상호 배제, Hold & Wait, 비선점 방식, 그리고 순환 대기이다. 상호 배제는 한 번에 하나의 프로세스만 공유 리소스를 사용 가능하다는 특성이고, Hold & Wait은 특정 리소스를 hold하고 있는 프로세스가 set 내 다른 프로세스가 hold 중인 리소스를 요청, 대기 중인 상황을 의미한다. 또한 이 경우 다른 프로세스가 hold한 리소스를 선점해올 수 없다는 특징과, 프로세스 및 리소스 간에 cycle을 형성하는 경우까지 모두 동시에 유지되어야 데드락이 발생한다.<br><br>
상호 배제를 충족하지 않을 경우, 동시에 여러 프로세스가 리소스에 접근이 가능하므로 교착 상태가 되지 않는다.
Hold & Wait이 아닐 경우, 다른 프로세스가 리소스를 release하기를 기다릴 필요가 없다.
비선점 방식이 아닐 경우, 필요로 하는 리소스를 다른 프로세스로부터 선점해올 수 있기에 기다릴 필요가 없다.
Cycle을 형성하지 않을 경우, 아직 필요 리소스를 프로세스가 할당받을 수 있기에 교착 상태가 되지 않는다.<br><br>
따라서, 4가지 조건이 모두 동시에 충족되어야만 교착 상태가 발생하므로, 각각의 조건은 충분조건이 될 수 없다.<br><br><br>
⑵<br>은행원 알고리즘은 시스템이 프로세스의 자원 할당 요청을 받았을 때, 만약 해당 요청을 받아들일 경우 프로세스 간 안전한 실행 순서가 존재하는지(즉, 안전한 상태인지)를 파악하고, 그에 따라 실제로 요청을 처리할지를 결정하는 알고리즘이다. 여기서 안전한 실행 순서란, 현재 사용 가능한 리소스를 가지고 각 프로세스가 요구하는 리소스 필요량을 실행 순서에 따라 커버할 수 있는지를 의미하는 것이다.
