---
layout: single
title:  "교착상태 Deadlock"
categories: Os
tags: [Os, ComputerScience]
toc: true

---

<br><br>

# 교착 상태 

 \- 프로세스 set에서 각각 리소스 보유하고 있고, set 내 다른 애가 가진 리소스를 얻기 위해 대기하는 blocked 프로세스의 집합

 \- 하드웨어 전반 or 프로세스 전반에 걸쳐 발생 가능

​    <br>

 \- 다리가 리소스, 자동차가 프로세스면 외다리에서 누군간 후진해야 / starvation도 가능!

​    <br>

 \- graph에서도 cycle만 안 만들어지면 교착 상태 없음 → cycle이 교착상태의 필요조건

 \- cycle 만들어졌는데 리소스들에 타입이 각 1개씩만 있으면 교착 상태임 (충분조건이 아닌 이유)

​    <br><br><br>

​    

## 교착 상태 필수 조건

아래 4가지 조건이 “동시에” 유지되어야 발생함<br>

① 상호 배제 : 한 번에 하나의 프로세스만 리소스 사용 가능

② Hold & Wait : 리소스를 hold한 프로세스가 다른 프로세스가 hold한 리소스를 wait

③ 비선점 : 리소스 가진 프로세스가 자발적으로 release해야만 가능

④ 순환 대기 : cycle 형성

  <br><br>  <br>

​    

## 교착 상태를 다루는 방법

① 교착 상태 방지(회피) : system이 절대로 교착 상태 안 되도록 보장

② 교착 상태 탐지/복구 : system이 교착 상태 되는 것은 가능, 단 그걸 복구함

③ 암 것도 안함 : 걍 무시하고 없는 걸로 간주 (놀랍게도 대다수 OS에서 채택;;)

​    <br><br>

​    

### 1-1. 교착상태 예방

\- 필수조건 4가지 중 하나가 절!대! 안 일어나게 하자

① 상호 배제 : 공유 불가능 리소스에 대해서는 할 수 있는 게 없음.

​              뭔 소리냐? 이거 안 되게 하면 파장 개크다는 의미임. 그러므로 포기하렴!

② Hold & Wait : 리소스 요청할 거면 아무것도 hold하지 않은 상태여라.

​    아니면 애초 실행 시작하기 전에 필요한 모든 리소스를 요청해라.

③ 비선점 : hold한 상태에서 당장 할당 안 되는 리소스 요청 시, 지금 hold한 것도 싹 다 release해버린다. 요청한 리소스 말고도 release당해버린 것까지 되찾을 수 있으면 그 때 다시 시작하게 해주마.

④ 순환 대기 : 리소스마다 고유 번호 부여, 프로세스에서 번호 순서대로 요청하도록 한다.<br><br><br>

### 1-2. 교착상태 회피

리소스 할당과 런타임 체크를 통해 교착상태를 회피한다

각 프로세스가 필요할 수 있는 최대 리소스 수를 선언

자원 할당 상태를 동적으로 검사 : cycle 발생 방지 보장

자원 할당 상태 : 가능한 자원 수 & 할당된 자원 수 & 프로세스 필요 최대 리소스 수

​    

​    

#### 안전 상태

프로세스가 가능 리소스를 요청할 때, system이 해당 요청에 대한 즉시 할당이 'system을 안전 상태로 두는지'를 확인해야 한다.

모든 프로세스들에 대한 **안전 순서**가 있을 경우 system이 안전 상태에 있다고 말함.

<br><br>

​    

※ 안전 상태면 교착 상태는 없다. 비안전 상태면 가능성이 있다.

※ ‘회피’는 system이 **절!대!** 비안전 상태로 진입하지 않도록 보장하는 방법이다.

   <br><br> 

​    

#### 뱅커 알고리즘 (회피 방법)

프로세스의 자원 할당 요청을 받아들였을 때 안전 순서가 존재한다면 받아들이고, 아니라면 대기시킨다.

① Available[j] : 모든 자원 j에 관한 사용 가능 개수

  ② Max[i, j] : 프로세스 i가 제시한 자원 j에 관한 최대 요구 개수

  ③ Allocation[i, j] : 프로세스 i에 할당된 자원 j의 개수

  ④ Need[i, j] : 프로세스 i가 추가적으로 필요로 하는 j의 개수

​    <br>

※ 안전 알고리즘

① Work는 사용 가능 자원 수 배열, Finish는 false로 처리된 프로세스 개수 성분의 배열

② Finish i번째가 false고 Need가 Work보다 작거나 같으면 ③으로, 그런 i 없으면 ④로.

③ Work에 Allocation 더하고 Finish는 true로 바꾼 뒤 ②로.

④ 모든 i에 대해 Finish true면 그 system은 안전 상태다.<br><br><br>

### 2. 교착 상태 탐지 & 복구

system 교착되게 냅두고 그 후에 deal한다.

리소스 요청에 대한 선험적 정보 없음

뱅커 알고리즘의 safety 알고리즘에서 Need를 Request로 바꿨을 때 안전 순서가 없으면

  → system은 교착된다.

​    <br>

​    <br>

#### 탐지 알고리즘

① Work는 사용 가능 자원 수 배열, Finish는 allocation 0이면 true, 아니면 false로.

② Finish i번째가 false고 Request가 Work보다 작거나 같으면 ③으로, 그런 i 없으면 ④로.

③ Work에 Allocation 더하고 Finish는 true로 바꾼 뒤 ②로.

④ Finish가 false인 i가 있으면 system은 교착된다. 또한 그 프로세스 i에서 교착된다.

​    <br>

※ 탐지 알고리즘을 매 요청마다 수행하는 건 상당한 오버헤드를 발생시킬 수 있음

​    <br><br>

​    

#### 교착상태 복구

① 프로세스 종료 : 종료된 프로세스에 할당된 모든 리소스 회수

  \- 교착된 프로세스를 전부 중지시킨다.

  \- 교착 cycle이 없어질 때까지 차례로 교착 프로세스를 중지시킨다.

  \- 그렇다면 어떤 차례로?

​    \1) 프로세스의 우선순위

​    \2) 연산 시간 & 남은 수행 예상 시간

​    \3) 프로세스가 사용한 리소스

​    \4) 프로세스가 종료까지 필요로 하는 리소스

​    \5) 종료되어야 하는 프로세스의 수

​    \6) 프로세스가 interactive인지 아닌지

  → 파일, 인쇄 작업 등 system이 일관되지 않을 수 있으므로, 쉽지 않은 방법이라고 하더라

​    <br>

② 자원 선점

  \- 희생자 선택 : 어떤 리소스와 프로세스를 선점할까?

  \- 역행 : 프로세스로부터 자원을 선점하면, 그 프로세스는 어떻게 될까?

​           안전 상태로 돌아가서 프로세스를 다시 시작

  \- Starvation : 발생 안 한다고 어떻게 보장할까? 늘 동일한 프로세스가 희생자로 선택됨
