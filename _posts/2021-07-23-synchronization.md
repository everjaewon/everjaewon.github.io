---
layout: single
title:  "프로세스 동기화(1/2) Process Synchronization(1/2)"
categories: Os
tags: [Os, ComputerScience]
toc: true

---

<br><br>

※ 멀티스레드 프로그래밍으로 어플리케이션 프로그래머도 프로그램 조정을 담당해야 함<br>

# 이슈

 \- 프로세스/스레드의 동시 처리는 데이터와 리소스를 종종 공유해야 하는데, 공유하는 데이터에 대한 접근이 제어되지 않을 경우 수행되는 작업에 일관성이 없어짐

 \- 보통은 OS 문제이나, 병렬 프로그래밍/멀티스레드 프로그래밍으로 확장되는 이슈임

​    <br><br><br><br>

​    

# 동기화 문제

 \- 두 개 이상의 concurrent 프로세스/스레드가 공유 리소스에 접근해서 조작하면?

   → 접근 시기에 따라 결과가 달라짐

​     ![img](file:///C:\Users\Shako\AppData\Local\Temp\DRW000004ec48fb.gif)   공유 리소스에 대한 접근 제어 메커니즘이 필요하다!

​       버퍼, 큐, 리스트 같은 모든 공유 자료구조에 대한 ‘동기화’ 필요!

​    <br><br><br><br>

​    

# 리소스 공유

프로세스 : 공유 메모리 객체, 파일 etc.<br>

스레드

  ① 지역 변수 : 공유 안 됨! (스레드는 자체 스택 가짐)

  ② 전역 변수 : 공유 됨!  (정적 데이터 segment에 저장됨)

  ③ 동적 객체 : 공유 됨!  (힙에 저장됨)

​    <br><br><br><br>

​    

# 임계 구역

 \- n개의 프로세스가 공유 데이터를 쓰기 위해 모두 경쟁하는 상황이고,

   각 프로세스는 공유 데이터에 접근하는 코드조각인 ‘임계 구역’을 갖고 있음

 \- 어느 프로세스가 임계구역에서 실행 중이면 다른 프로세스는 임계구역에서 실행되면 안 됨

​    <br><br>

​    

## 임계 구역 해결법에 대한 요구사항

 ① 상호 배제

  \- 특정 프로세스가 임계 구역에서 실행 중이면, 이 구역에서 다른 프로세스 실행 불가<br>

 ② Progress

  \- 임계 구역에서 실행 중인 프로세스가 없고 들어가려는 프로세스가 몇 개 있는 경우,

​    다음으로 구역에 들어갈 프로세스의 선택을 무기한 연기할 수 없음<br>

 ③ 제한된 대기(starvation 없음)

  \- 프로세스가 임계 구역 접근을 요청하고 그 요청이 승인되기 전에,

​    다른 프로세스가 구역에 접근할 수 있는 횟수에 대한 제한이 존재해야 함<br><br>

### 해결법 분석의 프레임워크

 \- 각 프로세스는 0이 아닌 속도로 실행된다. 허나,

   다른 프로세스들에 대한 상대적 속도에 관한 가정은 없음

 \- CPU는 여러 개 있을 수 있다. 허나,

   메모리 하드웨어는 동일한 메모리 위치에서 동시 접근이 되는 것을 방지한다.

 \- interleaving 실행 순서에 대한 가정은 없음

 **※** **해결을 위해서는 entry 구간과 exit 구간을 지정해야 함**

 <br><br><br>   

​    

## 임계 구역 해결법 분류

① 저수준 동기화 : Locks (매우 원초적인 방법, 다른 방법들의 수단으로 쓰임)

​                  software-only / hardware atomic Solution, 인터럽트 비활성화 etc.

② 고수준 동기화 : OS 또는 언어적 해결법, 일부 함수나 데이터 구조를 프로그래머에 제공

​    ex) 세마포어, Monitor etc.

​    <br>

​    

### Locks

 \- ‘락 풀릴 때까지 기다렸다가 락 걸기’ & ‘락 풀고, 기다리는 프로세스 깨우기’ 2개 작업

 \- acquire 써서 락 걸고 임계 구역 들어갔다가, release 써서 락 풀고 나온다.

   acquire는 락 걸릴 때까지 return 안 됨. 락은 한 놈만 걸 수 있다.

 \- 스핀락이다. (락을 획득할 때까지 루프를 돌면서 계속 재시도한다는 의미)

​    <br><br>

​    

### Software-only Solution

 \- 두 개의 프로세스가 있다고 가정

  ① 공유 변수가 i값을 충족하면 접근 : 상호 배제 충족, progress 미충족

  ② flag i번째 성분이 true면 i번째 프로세스가 접근 : 상호 배제 충족, progress 미충족

  ③ 피터슨 알고리즘(① + ②) : 조건 모두 충족

   <br> 

  **※ ③이 어떻게 조건을 모두 충족하나요?!**

   \- 상호 배제 : 둘 다 임계 구역 들어가려면 두 flag 모두 true에 turn값도 서로 숫자가 맞아야 하는데, 이건 불가능하므로 상호 배제 성립

   \- 나머지 :

​    ① 나는 쟤 flag와 turn값이 맞을 때만 구역에 못 들어간다

​    ② 쟤가 ready 안 됐다는 건 걔 flag가 false란 거고, 따라서 난 들어갈 수 있다

​    ③ 만약 쟤도 flag가 true면, turn값에 따라 달라진다

​    ④ turn이 내 꺼면 나, 쟤 꺼면 쟤가 들어가는데, 쟤 flag가 false로 바뀌면 내가 들간다.

​    ⑤ 그런데 쟤가 다시 flag를 true로 리셋할 시간이 있으면, turn값도 내 꺼가 된다.

​    ⑥ 내가 대기타는 동안 turn값을 쟤 꺼로 못 바꾸니까, 결국 내가 들어간다.

<br><br>

### Hardware Atomic Solution

 \- 일반적으로는 메모리 위치에 대한 접근이 동일 위치에 대한 다른 접근 시도를 배제하지만,

   이걸 확장해서 설계자가 동일 메모리 위치에서 ‘서로 떼어놓을 수 없는 두 가지 action’을 수행하는 ‘special’ 명령어를 제안.

 \- multi-CPU 환경에서도 이런 명령어의 수행은 상호 배제를 충족함. 따라서 나머지 조건 역시 충족하기 위해 **더 복잡한 알고리즘이 필요하다.**

 \- ex) Test-and-Set / Swap(또는 xchg) → 근데 둘 다 starvation 문제 발생 가능.

   

​    

### 스핀락

 \- 스핀락은 Software-Only, Hardware Atomic을 기반으로 한 해결법이다.

 \- 자원 낭비 : 스핀락은 락 얻을 때까지 무한 재시도하기 때문에 CPU 사용률이 높아지고, 이건 임계 구역이 길수록 (그래서 딴 놈이 오래 머물수록) 심해진다. 이미 락 걸어놓고 임계 구역 사용 중인 스레드가 인터럽트라도 걸리면 리얼 무한 스핀이기 때문에 낭비 심함!

 \- 그런고로 그 자체로는 안 쓰고 '고수준 동기화'의 수단으로써만 사용한다

​    

​    

### 인터럽트 비활성화

 \- 인터럽트를 안 쓰기 때문에 context switching도 없음

 \- cli, sti 명령어로 구현됨

 \- 그러나,

   ① 커널에서만 사용 가능

   ② 임계 구역이 길면 : 상호 배제 유지 but 실행 효율성 저하, 중요 이벤트 놓치거나 지연

   ③ 멀티프로세서 환경에서는 인터럽트가 없어서 상호 배제가 성립 안 됨

 \- 일반적으로 수용 가능한 방법은 아니므로, 역시나 고수준 동기화의 기본 요소 구현에 사용

​    <br><br>

​    

### 고수준 동기화

 \- 스핀락이나 인터럽트 비활성화는 짧고 간단한 임계 구역에서만 유용하다.

   그리고 얘네는 상호 배제 말고는 충족하는 게 없음.

 \- 따라서, ① 대기하는 프로세스를 block하고, ② 임계 구역 내의 인터럽트를 가능케 하는 요소들이 필요하다.

 \- **세마포어, Monitor, Critical Regions, Message Passing** etc.

 \- 운영체제나 언어에 의해 지원된다.

 \- '아토믹 락'이 이러한 요소들 구현에 사용된다.

​    <br>

※ 그리고 각 고수준 동기화 항목들에 대한 세부 설명은 다음부터~!
