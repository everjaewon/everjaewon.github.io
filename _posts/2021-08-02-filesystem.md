---
layout: single
title:  "파일 시스템(1/2) File System(1/2)"
categories: Os
tags: [Os, ComputerScience]
toc: true

---

<br><br>

# 파일 시스템 (Linux에서 지원)

• 디스크 기반 파일 시스템:

– Linux: 2차/3차/4차 확장 파일 시스템(Ext2, Ext3, Ext4), Reiser FS, UML의 hostfs, …

– Microsoft: MS-DOS, VFAT, NTFS

– ISO 9660 CD-ROM 및 UDF DVD 파일 시스템

– UNIX 파일 시스템 변형: sysv, UFS, MINIX

– 독점: OS/2, HFS(Macintosh)

​    <br>

• 네트워크 기반 파일 시스템:

– NFS(Sun), NCP(Novell)

– Microsoft의 CIFS(Common Internet File System) 및 SMB(Server Message Block)입니다.

​    <br>

• 특수 파일 시스템:

– 실제 디스크 공간 없이 가상 디스크만 사용할 수 있습니다.

– 예: /proc 파일 시스템, /sys 파일 시스템

<br><br><br><br>

# 기본 개념

• 장기 정보 스토리지 요구사항 → 파일 시스템

– 매우 많은 양의 정보를 저장할 수 있어야 합니다.

– 정보를 사용하는 프로세스가 종료된 후에도 정보가 유지되어야 합니다.

– 여러 프로세스가 동시에 정보에 액세스할 수 있어야 합니다.

​    <br>

• 파일 시스템 책임

– Secondary 스토리지(파일)에 대한 추상화 구현

– 논리적으로 파일 구성(디렉토리)

– 프로세스, 인력 및 기계 간의 데이터 공유를 허용합니다.

– 원치 않는 액세스로부터 데이터 보호(보안)

<br><br><br><br>

# 파일

• 파일

– 보조 스토리지에 기록된 관련 정보의 명명된 모음입니다.

– 전원 장애 및 시스템 재부팅 시에도 지속됩니다.

– OS는 파일을 통해 정보 스토리지에 대한 일관된 논리적 뷰를 제공합니다.

​    <br>

• 파일 구조

– 플랫: 바이트 시퀀스

– 단순 레코드 구조: 선, 고정 길이, 가변 길이

– 복잡한 구조

<br><br><br>

## 파일 형식

• 파일 유형은 다음과 같습니다.

– 파일 시스템에 의해 이해됨

  \>> 장치, 디렉터리, 심볼 링크 등

– OS에 의해 이해

  \>> 실행 파일, DLL, 소스 코드, 객체 코드, 텍스트 등

– 애플리케이션에서 이해

  \>> jpg, mpg, avi, mp3 등

 <br>   

• OS는 파일 형식을 어떻게 인식합니까?

​    

⑴ Microsoft Windows

– 파일 이름의 일부로 유형 포함: 이름+확장자

– 사용자와 운영 체제는 이름만으로도 파일 형식을 알 수 있습니다.

– 예제: a.com, b.exe, c.hwp, d.doc, …

​    <br>

⑵ UNIX

– '파일 이름+확장자' 힌트를 허용하지만, 이러한 확장자는 운영 체제에서 적용하거나 의존하지 않습니다. 대부분 사용자가 파일 내용 유형을 결정하는 데 도움이 됩니다.

– UNIX는 각 파일을 8비트 바이트 시퀀스로 간주하며, 운영 체제에서 이러한 비트를 해석하지 않습니다.

– 이 계획은 최대의 유연성을 제공하지만 지원이 거의 없습니다.

  \>> 각 응용프로그램은 입력 파일을 적절한 구조로 해석하기 위해 자체 코드를 포함해야 합니다.

<br><br><br>

## 파일 액세스

• 파일 액세스 방법

– 파일 시스템은 파일의 데이터에 액세스하는 다양한 방법을 지정하는 다양한 액세스 방법을 제공합니다.

<br>

• 순차 액세스

– 바이트를 한 번에 하나씩 순서대로 읽습니다.

<br>    

• 직접 액세스

– 블록/바이트 번호가 지정된 임의 액세스

  <br>  

• 레코드 액세스

– 파일은 고정 길이 또는 가변 길이 레코드의 배열로, 순차적으로 또는 레코드 번호로 랜덤하게 읽거나 작성됩니다.

   <br> 

• 인덱스 액세스

– 파일 시스템은 파일에 있는 각 레코드의 특정 필드에 대한 인덱스를 포함하고 해당 필드의 값을 읽으며 시스템이 인덱스(DB)를 통해 레코드를 찾습니다.

<br><br><br>

## 파일 작업

• 오픈 파일 테이블

– 디렉토리 검색 오버헤드를 피하기 위해 운영 체제는 **열려 있는 모든 파일에 대한 정보가 들어 있는 작은 테이블**(오픈 파일 테이블)을 유지합니다.

– 파일 작업이 요청되면 파일이 인덱스를 통해 이 테이블로 지정되므로 검색할 필요가 없습니다.

– **파일을 더 이상 사용하지 않으면 프로세스에 의해 파일이 닫히고 운영 체제가 열린 파일 테이블에서 해당 항목을 제거합니다.**

​    <br>

• open() 시스템 콜

– 대부분의 시스템은 프로그래머가 열려 있는() 시스템 호출을 통해 파일을 명시적으로 열어야 파일을 사용할 수 있습니다.

– open() 작업은 파일 이름을 사용하고 디렉토리를 검색하여 디렉토리 항목을 오픈 파일 테이블에 복사합니다.

– 일반적으로 open() 시스템 콜은 포인터(즉, 파일 descriptor)를 오픈 파일 테이블의 항목으로 반환합니다. 이 포인터는 모든 I/O 작업에 사용됩니다.

<br><br><br><br>

# 디렉토리

• 디렉토리

– 사용자에게 디렉토리는 체계적인 파일 구성 방법을 제공합니다.

– 파일 시스템의 경우, 디렉토리를 사용하면 논리 파일 구성과 디스크의 물리적 파일 배치를 구분할 수 있는 편리한 이름 지정 인터페이스를 제공합니다.

​    

• 계층적 디렉토리 시스템

– 대부분의 파일 시스템은 다중 수준의 디렉토리를 지원합니다.

– 대부분의 파일 시스템은 '현재 디렉토리(또는 작업 중인 디렉토리)'의 개념을 지원합니다.

  \>> 현재 디렉터리에 대해 지정된 상대 이름

  \>> 절대 이름은 디렉터리 트리의 루트부터 시작합니다.

<br><br><br>

## 디렉터리 내부

• 디렉토리는 다음과 같습니다.

– 일반적으로 특수 메타데이터가 들어 있는 파일입니다.

– 디렉토리 : (파일 이름, 파일 속성) 목록

– 속성에는 다음과 같은 것이 포함됩니다.

\>> 크기, 보호, 생성 시간, 액세스 시간,

\>> 디스크 상의 위치 등

– 일반적으로 순서가 지정되지 않음(효과적으로 랜덤함)

\>> 일반적으로 디렉토리를 읽는 프로그램별로 정렬된 항목입니다.

– 디렉터리 구조와 파일이 모두 디스크에 있습니다.

<br><br><br>

## 경로 이름(Pathname) 변환

• 개방형/a/b/c", …)

– "/" 디렉토리 열기(잘 알려져 있으며, 항상 찾을 수 있음)

– 디렉토리에서 "a"를 검색하고 "a"의 위치를 가져옵니다.

– 디렉토리 "a"를 열고 "b"를 검색하며 "b" 위치를 가져옵니다.

– 디렉토리 "b"를 열고 "c"를 검색한 후 "c" 위치를 가져옵니다.

– "c" 파일 열기

– (각 단계에서 권한 확인)

​    <br>

• 시스템이 디렉토리 경로를 따라 이동하는 데 많은 시간이 소요됨

– 이래서 open()이 read()/write()와 구분됩니다.

– OS가 성능을 향상시키기 위해 접두사 조회를 캐시합니다.

\>> /a/b, /a/bb, /a/bb, ... 모두 "/a" 접두사를 공유합니다.

<br><br><br>

## 디렉토리 작업(UNIX)

• 디렉토리가 파일(즉, inode)로 구현됩니다.

– 파일 작업을 사용하여 디렉토리 조작

   <br> 

• C 런타임 라이브러리(시스템 콜)

– 디렉토리 읽기에 대한 높은 수준의 추상화를 제공합니다.

– DIR *openir(const char *name);

– struct different *readdir (DIR *dir);

– void seekdir(DIR *dir, off_t offset);

– Int closedir(DIR *DIR);

   <br>

• 기타 디렉토리 관련 시스템 콜

– Intrename(const char *old path, const char *new path);

– intlink(const char *old path, const char *new path);

– intunlink(상수 문자 *경로 이름);

<br><br><br>

## 디렉토리 구성하기

• 효율성

– 빠른 파일 찾기

​    <br>

• Naming

– 사용자에게 편리함

– 두 명의 사용자가 서로 다른 파일에 대해 동일한 이름을 가질 수 있습니다.

– 동일한 파일에 여러 개의 다른 이름이 있을 수 있습니다.

​    <br>

• 그룹화

– 속성별로 파일을 논리적으로 그룹화합니다. (예: all C programs, all games, ...)

​    <br>

• 트리 구조 디렉토리

– 검색할 때 효율적

– 그룹화 기능

– 현재(작업 중인) 디렉토리

– $cd /mails/mail/prog

   <br> 

• 순환 그래프 디렉토리  
![image](https://raw.githubusercontent.com/everjaewon/everjaewon.github.io/master/assets/images/acyclicdirectory.png){: .align-center}{: width="50%" height="50%"}

– 공유 하위 디렉토리 및 파일 보유

– dict가 count를 삭제하는 경우 → 'dangling pointer'

– 솔루션:

\>> 모든 포인터를 삭제할 수 있도록, 백 포인터.

\>> 참조 횟수 세기

​    <br>

• 예: UNIX

– link 삭제는 원본 파일에는 영향을 주지 않으며 link만 제거됩니다.

– 파일을 삭제할 때 심볼 링크는 남아 있으며, 원본 파일이 사라졌거나 바뀌었음을 인식하는 것은 사용자에게 달려 있습니다.

<br><br><br><br>

# 파일 시스템 마운트

 • 마운트

– 파일 시스템을 시스템에서 프로세스에 사용하려면 먼저 mount해야 합니다.

\>> Windows: 문자를 구동합니다(예: C:\, D:\, ...).

\>> UNIX: 기존 빈 디렉터리(예: 마운트 지점)에 연결

<br><br><br><br>

# 파일 공유

• 다중 사용자 시스템에서 파일을 공유하는 것이 바람직합니다.

– 통신 및 동기화 기반.

– 분산 시스템에서는 네트워크(예: NFS)를 통해 파일을 공유할 수 있습니다.

​    <br>

• 파일 공유 시 주요 문제:

– 동시 접근의 의미:

\>> 한 프로세스는 읽고 다른 프로세스는 쓰면 어떻게 됩니까?

\>> 두 프로세스가 쓰기 위해 파일을 열면 어떻게 됩니까?

– 파일 잠금을 사용한 동시성 제어(즉, flock(), fcntl() 시스템 호출)

– 보호

<br><br><br>

## 보호

• 파일 시스템은 일종의 보호 시스템을 구현해야 합니다.

– 파일에 액세스할 수 있는 사용자 제어

– 액세스 방법 제어(읽기/쓰기/실행/추가/삭제 등)

  <br>  

• 일반화

– "객체"에 대한 파일 일반화 ("무엇 what")

– "대상자"에 대한 사용자 일반화 ("누구 who")

– "action"에 대한 읽기/쓰기 일반화 ("방법 how")

<br>    

• 보호 시스템

– 보호 시스템은 주어진 "객체"에 대해 주어진 "대상자"가 수행한 지정된 "action"을 허용해야 하는지 여부를 지정합니다.

  \>> 파일을 읽거나 쓸 수 있지만 다른 파일은 쓸 수 없습니다.

  \>> /etc/motd는 읽을 수 있지만 쓸 수는 없습니다.

​    <br>

• UNIX : ACL(액세스 list) 및 그룹

– 액세스 모드 : 읽기, 쓰기, 실행

– 3가지 사용자 클래스 : owner / groups / public

– 각각의 사용자 클래스에 대한 액세스 모드들의 활성화 여부가 지정되어 있음!

<br><br><br><br>

# 파일 시스템 구현

• 파일 시스템에 대한 사용자 관점:

– 파일 이름은 어떻게 지정됩니까?

– 어떤 작업이 허용됩니까?

– 디렉터리 트리는 어떻게 생겼습니까?

  <br>  

• 파일 시스템에 대한 '구현자(implementor)'의 관점:

– 파일 및 디렉토리는 어떻게 저장됩니까?

– 디스크 공간은 어떻게 관리됩니까?

– 모든 것이 효율적이고 안정적으로 작동하도록 하는 방법은 무엇입니까?

<br><br><br>   

## On-disk 구조

– 부트 컨트롤 블록

  \>> 시스템에서 해당 파티션에서 OS를 부팅하는 데 필요한 정보입니다.

  \>> UFS(유닉스 파일 시스템): 부팅 블록

  \>> Windows NTFS: 파티션 부트 섹터<br>

– 파티션 제어 블록

  \>> 파티션 세부 정보 포함: 파티션의 블록 수, 블록 크기, 사용 가능한 블록 수, 사용 가능한 FCB 수 등.

  \>> UFS: 슈퍼블록

  \>> Windows NTFS: 마스터 파일 테이블<br>

– 디렉토리 구조

  \>> 파일을 정리하는 데 사용<br>

– 개별 파일

  \>> 파일 데이터 + FCB

  \>> FCB에는 많은 파일 세부 정보가 포함되어 있습니다.

  \>> UFS : inode<br><br><br><br>

## In-memory 구조

– In-memory 정보는 캐슁을 통한 파일 시스템 관리 및 성능 향상에 모두 사용됩니다.<br>

– In-memory 파티션 테이블

  \>> 마운트된 각 파티션에 대한 정보를 포함합니다.<br>

– In-memory 디렉터리 구조

  \>> 최근에 액세스한 디렉토리의 디렉토리 정보를 보관합니다.<br>

– system-wide open-file table

  \>> 열려 있는 각 파일의 FCB 복사본을 포함합니다.<br>

– per-process open-file table

  \>> 시스템 전체 열린 파일 테이블의 해당 항목에 대한 포인터를 포함합니다.

​    

## 파일 입출력 시나리오: open() 시스템 콜

⑴ open() call은 파일 이름을 파일 시스템으로 전달합니다.

⑵ 디렉토리 구조가 지정된 파일 이름을 검색합니다.

⑶ 검색 결과 찾았으면, FCB가 메모리 내부의 system-wide open-file table로 복사됩니다.

⑷ per-process open-file table에서 엔트리가 만들어지고, 이 엔트리는 system-wide open-file table의 엔트리를 가리키는 포인터를 갖고 있습니다.

⑸ open() 콜이 per-process open-file table의 적절한 엔트리를 가리키는 포인터를 반환합니다.

⑹ 그러면, 모든 파일 작업이 이 포인터를 통해 수행됩니다.
<br><br><br><br><br>
# <span style="color:yellow">핵심 질문</span>
⑴ thrashing에 대한 설명<br>
⑵ copy-on-write 설명
<br><br><br><br>
⑴<br>FCB란 파일에 대한 정보를 구성하는 일종의 저장 자료구조를 말한다. 파일마다 독립적으로 존재하며 보조기억장치에 저장되었다가 파일을 open할 때 주기억장치로 전달된다.<br><br><br>
⑵<br>1. open() 시스템 콜이 file system에 파일 이름을 전달한다.<br>
2. 해당 이름에 대해 커널 속 directory sturcture가 검색된다.<br>
3. 검색됐으면 FCB가 커널 속 system-wide open-file table에 복사된다.<br>
4. 커널 속 per-process open-file table에 엔트리가 생성된다. (system-wide open-file table의 엔트리를 가리키는 포인터 有)<br>
5. open() 시스템 콜이 per-process file-system table의 적절한 엔트리에 포인터를 반환한다.<br>
6. 그리고 이 반환된 포인터를 통해 파일 작업이 수행된다.
