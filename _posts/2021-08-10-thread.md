---
layout: single
title:  "스레드 Thread"
categories: Os
tags: [Os, ComputerScience]
toc: true

---

<br><br>

# 프로세스 모델의 한계점

⑴ 다수의 작업을 동시에 다루기 위해 많은 프로그램이 fork로 스스로를 카피한다.  

​    → 주소 공간과 리소스가 공유되므로, 매우 비효율적(?)

⑵ 프로세스는 한 번에 하나의 프로세서만 사용 가능 → 멀티프로세서 환경 활용 불가

 \+ 자동 병렬화 없음

 (coarse-grain paralleism은 가능 : 프로세스의 명시적 생성 & 사용 가능 프로세서에 배포)

​    

## 프로세스는 “무겁다”

 \- 그러므로 새 프로세스 생성 시 image & context의 모든 데이터구조가 할당되어야 한다

 \- IPC 역시 일반적으로 OS를 거쳐야 하므로 고비용이다

<br><br><br><br>

# 멀티스레딩 모델

 \- 스레드 : 프로그램에서 실행 중인 명령어들.

​     PC, stack(지역변수 추적 및 레지스터 반환)으로 구성.

 \- 프로세스와 명령어 & 대부분의 데이터를 공유

 \- 프로세스의 OS state 역시 공유

​    <br><br>

기존 프로세스의 구성에서 이미지 中 스택 영역 가져오고, program context를 가져옴.

그래서 프로세스의 구성이 스레드 + 코드&데이터영역 + kernel context가 된다.

​    <br><br>

※ 프로세스 내에서 스레드 여러 개 갖기 가능!

 \- 스레드마다 PC 값의 순서가 존재함. (논리적 제어의 흐름)

 \- 스레드들은 코드&데이터 영역과 kernel context를 공유함. 스레드 외의 프로세스죠?

 \- 스레드마다 고유 ID가 존재함.

​    <br><br><br><br>

# 프로세스와 스레드의 비교

 \- 프로세스는 트리 형식 / 프로세스와 연관된 스레드들은 공유 구조 중심으로 풀 형성

 \- 웹 서버를 예로 들어보자!

  → fork()를 이용해 병렬 처리 프로세스를 생성하는 건 작업의 간단함에 비해 과한 부담

  → 스레드를 사용해 각 요청에 대한 스레드들을 생성하는 것이 가능

 \- 관계의 고전적인 해석 : 프로세스 = 스레드가 실행되는 컨테이너 (여러 스레드 보유 가능)

​                         → 프로세스는 정적, 스레드는 동적 개체가 됨

 \- 유사한 점 : 고유한 논리적 제어 흐름 존재 / 개별적으로 스케줄링 가능

 \- 다른 점 : 스레드는 코드&데이터 공유, 프로세스끼리는 아님 / 생성 및 종료의 비용 차이

​    <br><br><br><br>

# 스레드의 장점 

 \- 경제적 측면 : 동시성 > 저비용 / 생성, 종료, context switching에 쓰이는 시간이 적음

   스레드가 프로세스보다 생성은 30배, switching은 5배 빠르다.

 \- resource sharing으로 인한 communication 향상

   : 동일 주소 공간에서 메모리, 파일 공유 → 커널 호출 없이 통신 가능, 응답성↑

 \- 멀티프로세서 환경의 활용 : 각 스레드가 서로 다른 프로세서에서 병렬로 실행 가능

<br><br><br><br>

# 스레드의 실행 

 \- 스레드의 생성 및 관리 담당

  ① OS (kernel-level 스레드의 경우) : 생성&관리에 시스템 콜 필요하므로

  ② 유저 레벨 프로세스 (user-level 스레드의 경우) : 프로그램에 연결된 라이브러리가 관리  

<br>

 \- user-level 스레드의 관리가 가능한 이유

  ① 같은 주소 공간을 공유하므로 : 관리자가 주소 공간을 조작할 필요성이 없음

  ② 스레드가 다른 부분은 hardware context(PC, SP, 레지스터)에서뿐임

​     : 프로세스 자체에서 조작 가능

​    <br><br>

## User-level Threading 

 \- 커널이 스레드 자체를 인식 못함, 라이브러리 패키지가 모든 기능을 제공해 커널처럼 작동

 \- Kernel-level Threading을 지원하지 않는 system에서 사용된다.

 \- “다 대 일” 모델이다. 커널 스레드 or 프로세스 하나에 여러 유저스레드가 매핑됨.

 \- 장점 : 초경량 – 빠름, 저렴함, 커널 리소스 X > 전부 user space에서 해결!

 \- 단점 : 입출력 스레드가 프로세스를 block할 수 있음, 멀티프로세서 환경에서 성능 향상X

​    <br><br>

## Kernel-level Threading

 \- 커널에서 프로세스, 스레드에 대한 context 정보가 유지된다.

   ① 커널에서 내부적으로 필요에 따라 생성, 삭제

   ② 커널 텍스트와 전역데이터를 공유함

   ③ 자체 커널 스택을 보유

   ④ “독립적으로” 스케줄링됨

   ⑤ 커널의 표준 동기화 메커니즘을 사용함<br>

 \- “일 대 일” 모델이다. user-level 스레드 하나가 kernel thread 하나에 매핑됨.

 \- 장점 : 서로 다른 CPU에서 여러 스레드를 동시 실행 가능

​          단일 프로세서에서도 다른 스레드가 실행되는 동안 하나 이상의 스레드가 blocking 시스템 콜을 호출할 수 있다.

 \- 단점 : 무겁다 – 스레드 만들려면 커널 스레드도 만들어야 해서 시스템 콜 필요

​                   스레드 스케줄링하고 동기화할 때도 마찬가지

​    <br>

 \- 근데 “다 대 다” 모델도 있다. 다수의 user-level 스레드가 다수의 커널 스레드에 매핑됨.

 \- 장점 : ① 스레드 생성 자체는 user space에서 완전히 수행됨

​          ② 많은 스레드를 다른 CPU에서 병렬로 실행 가능

   ③ blocking 시스템 콜이 전체 프로세스를 block할 필요는 없음

 \- Solaris 2 : 다대다 모델의 변형판, 다대다와 일대일을 결합한 모델이라카더라.

<br><br><br><br>

# 스레드 인터페이스 

 \- 공급업체 종속 스레드의 종류가 여러 개 있다. 그 중 Pthread만 보자고.

 \- Pthreads

   \> 스레드의 생성, 동기화를 위한 POSIX 표준 API이다.

   \> API는 스레드 라이브러리의 동작을 지정함

   \> 구현은 라이브러리 개발의 몫

   \> UNIX 기반 OS에서 씀. 요즈음 대부분의 멀티스레딩 app은 pthread 라이브러리發.

​    <br><br><br><br>

# Linux의 스레드

 \- 리눅스의 멀티스레딩 지원 여부

   : fork()를 통한 프로세스 복제 외에는 kernel-level multithreading 지원하지 않음

 \- 대신, ‘경량 프로세스’를 제공함

   (※ 리눅스는 프로세스와 스레드를 구분하지 않는다. 대신 task라는 용어를 쓴다.)

   : clone() 시스템 콜을 통해 구현되는데, 얘는 복제된 프로세스를 만들지 않고, 상위 task의 주소 공간을 공유하는 별도의 프로세스를 만든다. 그 외엔 fork()와 유사함.

​     ※ clone()에서의 flag는 자식 프로세스와 공유되는 부모 프로세스의 수를 나타낼 때 씀

 \- Wa! 리눅스는 Pthreads 지원! UNIX 계열이니까 당연하겠죠?

​    

## Linux에서의 Pthreads 실행 

 \- LinuxThreads라고 일대일 모델 있었는데 이후 NPTL로 대체됨

 \- NGPT라고 다대다 모델이었는데 2003년 이후로 밴먹음

 \- NPTL이라고 RedHat에서 만든 일대일 모델 있음. 얘 clone() 씀. POSIX 표준 잘 준수함.

​    



### POSIX와의 호환성 문제

   : POSIX는 하나 이상의 스레드를 가진 하나의 프로세스고, 리눅스는 하나 이상의 리소스를 공유하는 별도의 task들이라는 점에서, 멀티스레딩 모델의 기본적 차이가 존재함.

​    <br><br><br><br>

​    

# 스레드 세 줄 요약 

① 스레드는 프로그램의 동시성을 위한 또다른 메커니즘을 제공함

② 스레드는 프로세스보다 cheap하고, 스레드 간 데이터 공유도 쉬워서 인기 많아지고 있음

③ 그러나 공유가 쉽다는 점은 “미묘한 동기화 오류”를 쉽게 발생시키므로, 비용이 듦
