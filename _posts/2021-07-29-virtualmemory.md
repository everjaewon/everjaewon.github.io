---
layout: single
title:  "가상 메모리(1/2) Virtual Memory(1/2)"
categories: Os
tags: [Os, ComputerScience]
toc: true

---

<br><br>

# 가상 주소

프로세스는 가상 주소(= 논리적 주소)를 사용한다

 • 가상 주소는 참조되는 데이터의 실제 물리적 위치와 독립적

 • CPU가 실행시키는 명령어는 가상 주소를 발급함

 • 가상 주소는 하드웨어에 의해, OS의 도움으로 물리적 주소로 translate된다.

 • 여러 프로세스의 메모리를 보다 쉽게 관리할 수 있게 된다.

가상 주소를 물리적 주소로 translate하는 메커니즘

 • 기본 기법 : partitioning, paging, segmentation etc.

 • 하드웨어와 OS의 지원을 요하는 기법 : MMU, TLB, Page Tables etc.

​    <br><br><br><br>

​    

# 가상 메모리 기법

핵심 개념

 • 사용자 논리적 메모리와 물리적 메모리의 “분리”<br>

장점

 • 프로세스를 서로 격리시킨다 : 각 프로세스는 고유의 고립된 주소 공간을 가짐

 • 프로세스들이 파일과 주소 공간을 쉽게 공유하도록 허용한다.

 • 프로그램의 전체 주소 공간을 물리적 메모리에 저장하지 않고도 실행시킬 수 있다.

  → 프로그램은 필요량보다 적은 RAM을 가진 machine에서도 실행될 수 있다

 • 많은 프로그램이 코드 or 데이터가 한 번에 모두 필요하지는 않다(또는 전혀 필요없다).

  → 절대 가져가지 않는 branch나, 절대 읽거나 쓰지 않는 데이터는 메모리 할당할 필요 X<br>

구현 : **Demand Paging**<br><br><br><br>

# Demand Paging

개념

 • “페이지가 필요할 때에만 페이지를 메모리로 가져온다.”

 • ‘page-level’ swapping을 하는 page system

 • OS는 메인 메모리를 시스템에서 할당한 프로세스 이미지의 cache(페이지)로 쓴다.

  → 처음엔 페이지가 프레임으로부터 할당되고, 물리적 메모리가 다 채워지면 특정 페이지가 선택되어 그 페이지의 물리적 메모리 프레임에서 방출당한다.

 • 방출당한 페이지는 디스크로 이동한다. (이런 일련의 페이지 이동은 OS에 의해 이뤄짐.)

(※ 페이지의 일부만 프레임에 load된다!)

각 page table 엔트리마다 ‘유효 비트’(= present 비트)가 연결된다

 • 1 : 메모리 內 / 0 : 메모리 內에 없음

 • 모든 엔트리에서 0으로 초기화되어 있다.

 • 주소 translate하는 중에 page table 엔트리의 비트가 0일 경우 : “**page fault**”<br><br><br>

## page fault의 handling

 • mapping되지 않은 페이지의 참조는 page fault를 생성

 • 방출된 페이지의 가상 주소를 참조하는 프로세스는 어떻게 되나요?!

  → 페이지에 접근하면, invalid한 page table 엔트리가 예외를 발생시킵니다!

  → 페이지가 방출되면 OS가 page table 엔트리를 ‘invalid’로 설정하고 swap file에 페이지의 위치를 저장합니다!

 • OS가 응답으로 page fault 핸들러를 실행시킵니다.

  → 핸들러는 페이지를 swap file에 위치시키기 위해 invalid한 page table 엔트리를 사용

  → 페이지를 물리적 프로엠으로 읽어들인 후 page table 엔트리를 valid로 갱신

  → faulted 프로세스를 재시작

 • 다 읽은 페이지는 어디로 이동하는가? : 무언가 방출해야 한다(페이지 교체 알고리즘)<br>

locality 덕에 이게 되네...

 • 시간적 locality : 최근에 참조됐던 위치는 곧 다시 참조됨

 • 공간적 locality : 최근 참조된 위치 근처의 위치가 곧 참조될 수 있음<br>

locality는 호출이 드물 수 있음을 의미

 : 한 번 호출하면 여러 번 사용되고, 평균적으로 우린 호출된 것들을 쓴다. 그리고 이는 여러 사항에 따라 달라진다.

  ① 응용 프로그램 內 locality의 정도

  ② 페이지 교체 정책

  ③ 물리적 메모리의 양

  ④ 응용 프로그램의 참조 패턴 & 메모리 이용 흔적?<br><br><br><br>

# 가상 메모리의 performance

page fault의 service time = page fault 인터럽트 + 페이지에서 읽기 + 프로세스 재시작

메모리 접근 시간과 디스크 접근 시간에서 확연한 차이가 나므로, OS가 페이지 교체를 잘 해야 한다.

<br><br><br><br>    

​    

# 사용가능 프레임 없으면 어떻게 되는가?

페이지 교체

 • 메모리에서 실제 사용 중이진 않은 페이지를 찾아 방출한다.

 • 더티 비트(= modify 비트)를 써서 페이지 전송의 오버헤드를 줄인다

   (modified된 페이지만 디스크에 기록된다)

 • 알고리즘 : 전체 page fault 수를 최소화하는 알고리즘이 필요하다!

 • 동일한 페이지를 메모리에 여러 번 들여올 수 있다.<br>

시사점

 • 페이지 교체는 논리적 메모리와 물리적 메모리 사이의 분리를 완료한다

 • 큰 가상 메모리는 더 작은 물리적 메모리에서 제공될 수 있다

​    <br><br><br>

​    

## 페이지 교체

기본 계획

 • 디스크에서 원하는 페이지를 위치를 찾는다

 • 사용가능 프레임 찾기 : 있으면 쓰고, 없으면 페이지 교체 알고리즘 써서 희생프레임 선택

 • 사용가능 프레임 內로 원하는 페이지를 읽어들인다.

 • 페이지/프레임 table을 update하고, 프로세스를 재시작 한다<br>

※ 대부분의 실제 OS에서는 사용가능 페이지 pool을 주위에 두어 할당이 불가피하게 방출을 발생시키지 않게 하려고 시도한다.<br>

최적의 페이지를 방출하기

 • 교체 알고리즘의 목표는 제거할 최적의 희생 페이지를 골라 fault rate를 줄이는 것이다.

 • 방출하기 최적의 페이지는 절대 한 번도 접근한 적 없는 페이지이다.

 • 따라서 ‘절대’에 가장 가까운 페이지를 선택하는 것이 차선책.<br>

벨라디의 증명 : 가장 오랫동안 쓰지 않을 페이지를 제거하면 page fault를 최소화한다.

​    <br><br><br>

​    

## 페이지 교체 알고리즘

목표 : 최저 page fault 발생률

알고리즘 : Optimal / FIFO / LRU / Clock / Counting-based / ...

알고리즘 평가

 • 특정 메모리 참조 string에서 알고리즘을 실행하고, 그 string에서의 page fault 수를 계산함으로써 알고리즘을 평가한다.<br><br>

### Optimal 알고리즘

가장 오랜 시간동안 쓰이지 않을 페이지를 교체한다.

 • 미래에 대한 지식 필요

 • 구현 불가 (비교 목적으로만 쓴다)

​    <br><br>

​    

### FIFO 알고리즘

가장 오래된 페이지를 교체한다 : 구현하기 쉬움

**벨라디의 이상현상** : 더 많은 프레임이 FIFO 알고리즘에 대한 성능 향상을 가져오진 않음

​    <br><br>

​    

### LRU 알고리즘

가장 오랫동안 안 쓰인 페이지를 교체한다

마지막 페이지 접근을 어떻게 추적하는가?

 • 해결책 후보 : 카운터, 스택

 • 특별한 하드웨어 지원이 필요할 것<br>

카운터

 • 하드웨어 clock이 모든 메모리 참조마다 tick한다.

 • 참조된 페이지는 이 시간으로 마킹된다.

 • 가장 작은 시간값을 가진 페이지가 교체된다.<br>

스택

 • 참조의 스택을 쌓는다.

 • 페이지에 참조할 때마다, 스택의 상단에 옮긴다.

 • 스택의 바닥에 있는 페이지가 다음 교체 대상이다.

​    

​    <br>

#### LRU 구현 : 스택

최근 사용된 페이지 스택을 유지한다

 : 최근 사용 현황에 따라

항상 스택 바닥의 페이지를 교체한다.

​    

​    

### 교체를 위한 하드웨어 지원

대부분의 시스템은 각 페이지마다 page table에 참조 비트를 제공한다

 • 페이지 참조에서 이 비트는 1로 설정된다.

 • OS에 의해 지워질 수 있다!<br>

이 간단한 하드웨어는 LRU에 근사한 다양한 알고리즘들을 끌어냈다.

 : Sampled LRU, Clock algorithm, ...<br><br>

#### LRU 근사 : Sampled LRU

각 페이지마다 참조 byte를 유지한다.

시간 간격마다 인터럽트를 넣어서 OS를 참여시킨다.

 • OS는 각 페이지의 참조 비트를 읽는다.

 • 참조 비트는 페이지의 시작 바이트에 채워진다.

 • 그 후 모든 참조 비트가 지워진다.

page fault에서, 참조 바이트가 가장 작은 페이지를 교체한다!

​    

<br>

#### LRU 근사 : Clock 알고리즘

많은 LRU 근사 알고리즘들이 참조 비트를 쓴다.<br>

LRU 시계 / Second-chance

 • 최근에 참조된 페이지에게 두 번째 기회를 주는 FIFO

 • 모든 페이지 프레임을 큰 원으로 정렬<br>

시계 바늘은 좋은 LRU 후보를 고르는 데에 쓰인다.

 • 각 참조마다 참조 비트는 하드웨어가 설정한다.

 • page fault 때 clock은 참조 비트가 0인 페이지들을 훑는다.

 • 페이지의 참조 비트가 1로 설정되어 있으면, 0으로 바꾸고 건너뛴다(두 번째 찬스 준다).

 • clock을 한 바퀴 도는 동안 참조되지 않은 페이지를 교체한다.

​    <br>

​    

#### 양손 clock 알고리즘

특징

 • faulting 프로세스를 assign하기 위해 사용가능 페이지 리스트를 유지한다.

   (lotsfree : paging을 시작할 임계값 매개변수)

 • pageout 프로세스에 의해 paging이 수행된다. pageout은 양손 clock 알고리즘을 써서 페이지를 스캔한다. 사용가능 메모리가 많을수록 pageout이 호출되는 횟수도 빈번해진다.

   (scanrate : 페이지가 스캔되는 속도. slowscan ~ fastscan이 범위.)

 • 이거 동작하는 걸 한 마디로 이야기하자면, 얘는 시계바늘이 2개라서 앞에 바늘이 먼저 지나고 시간차로 두 번째 바늘이 오기 때문에 그냥 clock보다 더 짧은 시간 기준으로 교체 대상 후보를 고를 수 있다.  

(바늘 하나로는 다시 같은 위치로 오려면 일단 한 바퀴를 돌아야 한다)

​    

​    

#### Counting 알고리즘

각 페이지가 참조된 횟수를 세는 counter를 유지한다.

LFU 알고리즘 : 횟수가 가장 적은 페이지를 교체한다.

MFU 알고리즘 : 횟수가 가장 많은 페이지를 교체한다.

​       (가장 적은 횟수의 페이지가 방금 가져왔고 아직 사용 안 됐다는 가정에 기반)
