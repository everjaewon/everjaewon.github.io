---
layout: single
title:  "가상 메모리(1/2) Virtual Memory(1/2)"
categories: Os
tags: [Os, ComputerScience]
toc: true

---

<br><br>

# 가상 주소

프로세스는 가상 주소(= 논리적 주소)를 사용한다

 • 가상 주소는 참조되는 데이터의 실제 물리적 위치와 독립적

 • CPU가 실행시키는 명령어는 가상 주소를 발급함

 • 가상 주소는 하드웨어에 의해, OS의 도움으로 물리적 주소로 translate된다.

 • 여러 프로세스의 메모리를 보다 쉽게 관리할 수 있게 된다.

가상 주소를 물리적 주소로 translate하는 메커니즘

 • 기본 기법 : partitioning, paging, segmentation etc.

 • 하드웨어와 OS의 지원을 요하는 기법 : MMU, TLB, Page Tables etc.

​    <br><br><br><br>

​    

# 가상 메모리 기법

핵심 개념

 • 사용자 논리적 메모리와 물리적 메모리의 “분리”<br>

장점

 • 프로세스를 서로 격리시킨다 : 각 프로세스는 고유의 고립된 주소 공간을 가짐

 • 프로세스들이 파일과 주소 공간을 쉽게 공유하도록 허용한다.

 • 프로그램의 전체 주소 공간을 물리적 메모리에 저장하지 않고도 실행시킬 수 있다.

  → 프로그램은 필요량보다 적은 RAM을 가진 machine에서도 실행될 수 있다

 • 많은 프로그램이 코드 or 데이터가 한 번에 모두 필요하지는 않다(또는 전혀 필요없다).

  → 절대 가져가지 않는 branch나, 절대 읽거나 쓰지 않는 데이터는 메모리 할당할 필요 X<br>

구현 : **Demand Paging**<br><br><br><br>

# Demand Paging

개념

 • “페이지가 필요할 때에만 페이지를 메모리로 가져온다.”

 • ‘page-level’ swapping을 하는 page system

 • OS는 메인 메모리를 시스템에서 할당한 프로세스 이미지의 cache(페이지)로 쓴다.

  → 처음엔 페이지가 프레임으로부터 할당되고, 물리적 메모리가 다 채워지면 특정 페이지가 선택되어 그 페이지의 물리적 메모리 프레임에서 방출당한다.

 • 방출당한 페이지는 디스크로 이동한다. (이런 일련의 페이지 이동은 OS에 의해 이뤄짐.)

(※ 페이지의 일부만 프레임에 load된다!)

각 page table 엔트리마다 ‘유효 비트’(= present 비트)가 연결된다

 • 1 : 메모리 內 / 0 : 메모리 內에 없음

 • 모든 엔트리에서 0으로 초기화되어 있다.

 • 주소 translate하는 중에 page table 엔트리의 비트가 0일 경우 : “**page fault**”<br><br><br>

## page fault의 handling

 • mapping되지 않은 페이지의 참조는 page fault를 생성

 • 방출된 페이지의 가상 주소를 참조하는 프로세스는 어떻게 되나요?!

  → 페이지에 접근하면, invalid한 page table 엔트리가 예외를 발생시킵니다!

  → 페이지가 방출되면 OS가 page table 엔트리를 ‘invalid’로 설정하고 swap file에 페이지의 위치를 저장합니다!

 • OS가 응답으로 page fault 핸들러를 실행시킵니다.

  → 핸들러는 페이지를 swap file에 위치시키기 위해 invalid한 page table 엔트리를 사용

  → 페이지를 물리적 프로엠으로 읽어들인 후 page table 엔트리를 valid로 갱신

  → faulted 프로세스를 재시작

 • 다 읽은 페이지는 어디로 이동하는가? : 무언가 방출해야 한다(페이지 교체 알고리즘)<br>

locality 덕에 이게 되네...

 • 시간적 locality : 최근에 참조됐던 위치는 곧 다시 참조됨

 • 공간적 locality : 최근 참조된 위치 근처의 위치가 곧 참조될 수 있음<br>

locality는 호출이 드물 수 있음을 의미

 : 한 번 호출하면 여러 번 사용되고, 평균적으로 우린 호출된 것들을 쓴다. 그리고 이는 여러 사항에 따라 달라진다.

  ① 응용 프로그램 內 locality의 정도

  ② 페이지 교체 정책

  ③ 물리적 메모리의 양

  ④ 응용 프로그램의 참조 패턴 & 메모리 이용 흔적?<br><br><br><br>

# 가상 메모리의 performance

page fault의 service time = page fault 인터럽트 + 페이지에서 읽기 + 프로세스 재시작

메모리 접근 시간과 디스크 접근 시간에서 확연한 차이가 나므로, OS가 페이지 교체를 잘 해야 한다.

<br><br><br><br>    

​    

# 사용가능 프레임 없으면 어떻게 되는가?

페이지 교체

 • 메모리에서 실제 사용 중이진 않은 페이지를 찾아 방출한다.

 • 더티 비트(= modify 비트)를 써서 페이지 전송의 오버헤드를 줄인다

   (modified된 페이지만 디스크에 기록된다)

 • 알고리즘 : 전체 page fault 수를 최소화하는 알고리즘이 필요하다!

 • 동일한 페이지를 메모리에 여러 번 들여올 수 있다.<br>

시사점

 • 페이지 교체는 논리적 메모리와 물리적 메모리 사이의 분리를 완료한다

 • 큰 가상 메모리는 더 작은 물리적 메모리에서 제공될 수 있다

​    <br><br><br>

​    

## 페이지 교체

기본 계획

 • 디스크에서 원하는 페이지를 위치를 찾는다

 • 사용가능 프레임 찾기 : 있으면 쓰고, 없으면 페이지 교체 알고리즘 써서 희생프레임 선택

 • 사용가능 프레임 內로 원하는 페이지를 읽어들인다.

 • 페이지/프레임 table을 update하고, 프로세스를 재시작 한다<br>

※ 대부분의 실제 OS에서는 사용가능 페이지 pool을 주위에 두어 할당이 불가피하게 방출을 발생시키지 않게 하려고 시도한다.<br>

최적의 페이지를 방출하기

 • 교체 알고리즘의 목표는 제거할 최적의 희생 페이지를 골라 fault rate를 줄이는 것이다.

 • 방출하기 최적의 페이지는 절대 한 번도 접근한 적 없는 페이지이다.

 • 따라서 ‘절대’에 가장 가까운 페이지를 선택하는 것이 차선책.<br>

벨라디의 증명 : 가장 오랫동안 쓰지 않을 페이지를 제거하면 page fault를 최소화한다.

​    <br><br><br>

​    

## 페이지 교체 알고리즘

목표 : 최저 page fault 발생률

알고리즘 : Optimal / FIFO / LRU / Clock / Counting-based / ...

알고리즘 평가

 • 특정 메모리 참조 string에서 알고리즘을 실행하고, 그 string에서의 page fault 수를 계산함으로써 알고리즘을 평가한다.<br><br>

### Optimal 알고리즘

가장 오랜 시간동안 쓰이지 않을 페이지를 교체한다.

 • 미래에 대한 지식 필요

 • 구현 불가 (비교 목적으로만 쓴다)

​    <br><br>

​    

### FIFO 알고리즘

가장 오래된 페이지를 교체한다 : 구현하기 쉬움

**벨라디의 이상현상** : 더 많은 프레임이 FIFO 알고리즘에 대한 성능 향상을 가져오진 않음

​    <br><br>

​    

### LRU 알고리즘

가장 오랫동안 안 쓰인 페이지를 교체한다

마지막 페이지 접근을 어떻게 추적하는가?

 • 해결책 후보 : 카운터, 스택

 • 특별한 하드웨어 지원이 필요할 것<br>

카운터

 • 하드웨어 clock이 모든 메모리 참조마다 tick한다.

 • 참조된 페이지는 이 시간으로 마킹된다.

 • 가장 작은 시간값을 가진 페이지가 교체된다.<br>

스택

 • 참조의 스택을 쌓는다.

 • 페이지에 참조할 때마다, 스택의 상단에 옮긴다.

 • 스택의 바닥에 있는 페이지가 다음 교체 대상이다.

​    

​    <br>

#### LRU 구현 : 스택

최근 사용된 페이지 스택을 유지한다

 : 최근 사용 현황에 따라

항상 스택 바닥의 페이지를 교체한다.

​    

​    

### 교체를 위한 하드웨어 지원

대부분의 시스템은 각 페이지마다 page table에 참조 비트를 제공한다

 • 페이지 참조에서 이 비트는 1로 설정된다.

 • OS에 의해 지워질 수 있다!<br>

이 간단한 하드웨어는 LRU에 근사한 다양한 알고리즘들을 끌어냈다.

 : Sampled LRU, Clock algorithm, ...<br><br>

#### LRU 근사 : Sampled LRU

각 페이지마다 참조 byte를 유지한다.

시간 간격마다 인터럽트를 넣어서 OS를 참여시킨다.

 • OS는 각 페이지의 참조 비트를 읽는다.

 • 참조 비트는 페이지의 시작 바이트에 채워진다.

 • 그 후 모든 참조 비트가 지워진다.

page fault에서, 참조 바이트가 가장 작은 페이지를 교체한다!

​    

<br>

#### LRU 근사 : Clock 알고리즘

많은 LRU 근사 알고리즘들이 참조 비트를 쓴다.<br>

LRU 시계 / Second-chance

 • 최근에 참조된 페이지에게 두 번째 기회를 주는 FIFO

 • 모든 페이지 프레임을 큰 원으로 정렬<br>

시계 바늘은 좋은 LRU 후보를 고르는 데에 쓰인다.

 • 각 참조마다 참조 비트는 하드웨어가 설정한다.

 • page fault 때 clock은 참조 비트가 0인 페이지들을 훑는다.

 • 페이지의 참조 비트가 1로 설정되어 있으면, 0으로 바꾸고 건너뛴다(두 번째 찬스 준다).

 • clock을 한 바퀴 도는 동안 참조되지 않은 페이지를 교체한다.

​    <br>

​    

#### 양손 clock 알고리즘

특징

 • faulting 프로세스를 assign하기 위해 사용가능 페이지 리스트를 유지한다.

   (lotsfree : paging을 시작할 임계값 매개변수)

 • pageout 프로세스에 의해 paging이 수행된다. pageout은 양손 clock 알고리즘을 써서 페이지를 스캔한다. 사용가능 메모리가 많을수록 pageout이 호출되는 횟수도 빈번해진다.

   (scanrate : 페이지가 스캔되는 속도. slowscan ~ fastscan이 범위.)

 • 이거 동작하는 걸 한 마디로 이야기하자면, 얘는 시계바늘이 2개라서 앞에 바늘이 먼저 지나고 시간차로 두 번째 바늘이 오기 때문에 그냥 clock보다 더 짧은 시간 기준으로 교체 대상 후보를 고를 수 있다.  

(바늘 하나로는 다시 같은 위치로 오려면 일단 한 바퀴를 돌아야 한다)

​    

​    

#### Counting 알고리즘

각 페이지가 참조된 횟수를 세는 counter를 유지한다.

LFU 알고리즘 : 횟수가 가장 적은 페이지를 교체한다.

MFU 알고리즘 : 횟수가 가장 많은 페이지를 교체한다.

​       (가장 적은 횟수의 페이지가 방금 가져왔고 아직 사용 안 됐다는 가정에 기반)
<br><br><br><br><br>
# <span style="color:yellow">핵심 질문</span>
⑴ Page Table과 그 종류에 대해서 설명하시오<br>
⑵ Segmentation에 대해서 설명하고 paging과 비교하고, 세그먼트와 페이징을 같이 이용하는 것에 대해 설명하시오.
<br><br><br><br>
⑴<br>실행 시에 사용되는 메모리의 양에 비해 큰 크기의 page table을 통으로 연속적으로 할당하는 것은 부담이 되기에, 이를 완화하기 위해 다양한 구조의 page table이 존재한다. 계층적 paging, hashed page table, inverted page table이 대표적인 예이다.<br><br>
Multi-level paging은 page number를 여러 개의 공간으로 나누어, 다중 계층의 table 구조를 사용하는 기법을 말한다. 논리적 주소 공간을 쪼개 다수의 table을 만들고, 각 table의 bit수는 적어지기에 상대적으로 메모리 공간 낭비를 덜할 수 있다.<br><br>
Hashed page table은 page number를 입력값으로 하는 hash 함수와, 그 결과값을 저장하는 hash table을 활용한 기법이다. page number가 주어지면 그에 상응하는 결과값을 table에서 찾고, 그 결과값에 연결된 linked list에서 해당하는 실제 메모리를 찾아가는 과정을 거친다.<br><br>
Inverted page table은 이름 그대로 기존의 page table처럼 page의 관점에서 frame을 mapping하는 것이 아닌, 실제 메모리 상의 frame의 관점에서 page를 mapping할 때 사용되는 table이다. 프로세스 내부의 page table과는 달리, 현재 실제로 사용되고 있는 frame들에 한해 page가 mapping되기에, table에 값을 저장할 때 필요한 메모리를 줄여준다는 장점이 있지만, page reference 발생 시 table을 탐색하는 시간이 늘어난다는 단점도 존재한다. table이 page를 mapping할 때 해당 page가 어느 프로세스와 대응되는지에 대한 정보도 필요하기 때문에, 프로세스 번호인 pid값도 담고 있다.<br><br><br>
⑵<br>segmentation은 메모리 공간을 일련의 논리적 구조 단위로 나누어, 사용자의 관점에서 메모리의 상태를 이해하는 데에 도움을 주는 기법이다. 코드, 스택, 함수, 객체 등 logical한 unit을 segment라 부르며, program은 이 segment들의 모음이라고 할 수 있다. segment의 논리적 주소는 segment number와 offset으로 구성되며, 이를 물리적 주소와 mapping시켜주는 segment table이 존재한다. table에는 크게 base와 limit이 존재하고, 또한 이에 대한 각각의 레지스터가 존재하는데, base는 segment의 시작 지점을, limit은 segment의 size 정보를 나타내고 있다. segment number를 limit과 비교하여 올바른 주소 참조가 되고 있는지 검사가 가능하며, base 정보와 결합하여 물리적 주소를 찾을 수 있게 된다. 논리적 주소 공간에 number와 offset이 존재하고, 이를 물리적 주소와 mapping시켜주는 table이 존재한다는 점에서 paging과 그 구조가 상당히 유사하다고 볼 수 있다.
각 segment는 서로 그 size가 다양하기 때문에, segment에 대한 메모리 할당은 곧 동적 할당 문제가 되며, 따라서 외부 단편화 문제가 존재한다. 반면 고정된 크기의 메모리 단위만을 사용하는 paging은 소규모의 내부 단편화 문제를 만든다는 차이가 있다.<br><br>
segmentation과 paging이 직접적인 연관성을 띠고 있지는 않지만, 두 기법의 이점을 모두 취하기 위해서 대다수의 시스템에서는 둘을 결합하여 사용한다. 우선, 논리적으로 연관되어있는 unit들을 관리하기가 용이하다는 점에서 segment를 쓴다. segment는 size가 다양하고 대부분 크다는 점에서 단점이 존재하는데, 이를 segment를 고정된 크기의 덩어리들, 즉 page로 분할함으로써 완화시킨다. 더 작은 단위의 page로 나누어져있기에 전체 segment를 메모리 안팎으로 이동시키기보다는, 사용되는 page 부분만을 이동시킴으로써 물리적 메모리를 관리하기가 쉬워지는 것이다.<br><br>
각 개별 segment는 paging된 가상 주소 공간으로 구현되며, 논리적 주소는 segment number, page number, page offset의 3가지로 구성된다. 이렇게 segment를 적극 사용하고 이를 page 단위로 분할하여 사용함으로써 각 기법의 장점을 모두 활용하고, 보호와 공유 측면에서도 추가적인 이득을 취할 수 있기에 흔히 사용된다.
